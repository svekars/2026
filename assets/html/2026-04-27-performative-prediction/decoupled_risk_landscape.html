<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 10px 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: transparent;
        }
        .controls {
            text-align: center;
            padding-top: 60px;
            padding-bottom: 8px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
        .controls-inner {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 4px;
            border-radius: 30px;
            box-shadow: 0 3px 12px rgba(102, 126, 234, 0.35);
        }
        .controls button {
            width: 32px;
            height: 32px;
            border: none;
            background: #ffffff;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #667eea;
            box-shadow: 0 1px 4px rgba(0,0,0,0.12);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        .controls button svg {
            display: block;
        }
        .controls button .arrow {
            display: block;
        }
        .controls button .spinner {
            display: none;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(102, 126, 234, 0.3);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }
        .controls button.loading .arrow {
            display: none;
        }
        .controls button.loading .spinner {
            display: block;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .controls button:hover:not(:disabled) {
            background: #f0f4ff;
            transform: scale(1.08);
        }
        .controls button:active:not(:disabled) {
            transform: scale(0.95);
        }
        .controls button:disabled {
            opacity: 0.35;
            cursor: not-allowed;
            background: rgba(255,255,255,0.5);
            box-shadow: none;
        }
        .step-display {
            display: flex;
            align-items: baseline;
            gap: 4px;
            padding: 0 10px;
        }
        .step-display .step-number {
            font-size: 16px;
            font-weight: 700;
            color: #ffffff;
        }
        .step-display .step-label {
            font-size: 11px;
            color: rgba(255,255,255,0.7);
        }
        .instructions {
            font-size: 11px;
            color: #999;
            margin-top: 4px;
            margin-bottom: 60px;
            font-style: italic;
        }
        .container {
            display: flex;
            gap: 20px;
            width: 100%;
            height: 420px;
        }
        #plot {
            flex: 1;
            height: 100%;
        }
        #risk-chart {
            flex: 1;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #loading {
            text-align: center;
            padding: 20px;
            font-size: 16px;
            color: #666;
        }
        svg {
            overflow: visible;
        }
    </style>
</head>
<body>
    <div id="loading">Loading data...</div>
    <div class="controls" style="display: none;">
        <div class="controls-inner">
            <button id="prev-btn" disabled title="Previous step">
                <svg class="arrow" width="12" height="12" viewBox="0 0 12 12" fill="none">
                    <path d="M8 2L4 6L8 10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <div class="spinner"></div>
            </button>
            <div class="step-display">
                <span class="step-number" id="step-current">1</span>
                <span class="step-label">of 25</span>
            </div>
            <button id="next-btn" title="Next step">
                <svg class="arrow" width="12" height="12" viewBox="0 0 12 12" fill="none">
                    <path d="M4 2L8 6L4 10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <div class="spinner"></div>
            </button>
        </div>
        <div class="instructions">
            Step through the optimization process
        </div>
    </div>
    <div class="container">
        <div id="plot"></div>
        <div id="risk-chart"></div>
    </div>

    
    <script>
        // Global variables
        let landscapeData = null;
        let algorithmTrajectories = {};
        let currentAlgorithm = 'PerfGDReparam';
        let showDiagonal = true;
        
        // State for progressive visualization
        let currentStep = 1;
        let totalSteps = 25; // Will be updated based on actual data (13 points + 12 lines)
        
        // 2D chart element references for progressive reveal
        let riskChartPoints = [];
        let riskChartLines = [];
        let riskChartData = null;
        
        // Plotly trace indices
        let plotlyPointsTraceIndex = -1; // Index of the main scatter3d trace for points
        let plotlyLineTraceStartIndex = -1; // Index where line segment traces start
        
        // Load the pricing landscape data
        async function loadLandscape() {
            try {
                const cacheBuster = new Date().getTime();
                const response = await fetch(`./json/decoupled_risk_surface.json?v=${cacheBuster}`);
                const data = await response.json();
                
                const landscapeMatrix = data.landscape[0];
                const transposed = landscapeMatrix[0].map((_, colIndex) => 
                    landscapeMatrix.map(row => row[colIndex])
                );
                
                landscapeData = {
                    x: data.x[0].map(arr => arr[0]),
                    y: data.y[0].map(arr => arr[0]),
                    z: transposed
                };
                return true;
            } catch (error) {
                console.error('Error loading landscape:', error);
                createDemoData();
                return false;
            }
        }
        
        // Load algorithm trajectory
        async function loadTrajectory(name, filename, maxIterations = null) {
            try {
                const cacheBuster = new Date().getTime();
                const response = await fetch(`./json/${filename}?v=${cacheBuster}`);
                const data = await response.json();
                
                const limit = maxIterations !== null ? Math.min(maxIterations * 2 + 1, data.p_d.length) : data.p_d.length;
                
                algorithmTrajectories[name] = {
                    p_d: data.p_d.slice(0, limit).map(arr => arr[0]),
                    p_m: data.p_m.slice(0, limit).map(arr => arr[0]),
                    losses: data.losses.slice(0, limit),
                    iterations: data.iteration.slice(0, limit)
                };
            } catch (error) {
                console.error(`Error loading ${name}:`, error);
            }
        }
        
        // Create demo data if loading fails
        function createDemoData() {
            const n = 50;
            const range = 4;
            const x = [], y = [];
            
            for (let i = 0; i < n; i++) {
                x.push(-range + 2 * range * i / (n - 1));
                y.push(-range + 2 * range * i / (n - 1));
            }
            
            const zGrid = [];
            for (let i = 0; i < n; i++) {
                const row = [];
                for (let j = 0; j < n; j++) {
                    const tM = y[j];
                    const tD = x[i];
                    const risk = Math.pow(tM - tD + 1, 2) + 0.5 * Math.pow(tM, 2);
                    row.push(risk);
                }
                zGrid.push(row);
            }
            
            landscapeData = { x, y, z: zGrid };
        }
        
        // Create the 3D plot (left side)
        function createPlot() {
            const traces = [];
            
            // 1. Surface Plot
            traces.push({
                type: 'surface',
                x: landscapeData.x,
                y: landscapeData.y,
                z: landscapeData.z,
                colorscale: 'YlGnBu',
                showscale: true,
                name: 'DPR(θ_D, θ_M)',
                hovertemplate: 'θ<sub>D</sub>: %{x:.3f}<br>θ<sub>M</sub>: %{y:.3f}<br>DPR: %{z:.3f}<extra></extra>',
                hoverlabel: {
                    bgcolor: '#f2f2f2ff',  
                    font: { color: 'black' }
                },
                colorbar: {
                    title: 'DPR',
                    len: 0.7,
                    x: -0.15,
                    xanchor: 'left'
                }
            });
            
            // 2. Diagonal Line
            if (showDiagonal) {
                const diagonalZ = landscapeData.x.map((val, i) => {
                    const idx = Math.floor(i * landscapeData.z.length / landscapeData.x.length);
                    return landscapeData.z[idx][i];
                });
                
                traces.push({
                    type: 'scatter3d',
                    mode: 'lines',
                    x: landscapeData.x,
                    y: landscapeData.x,
                    z: diagonalZ,
                    line: { color: 'black', width: 8 },
                    name: 'PR(θ): θ<sub>M</sub> = θ<sub>D</sub>',
                    hovertemplate: 'θ: %{x:.3f}<br>PR: %{z:.3f}<extra></extra>'
                });
            }
            
            // 3. Trajectory Points Trace (Markers only)
            // We will update this trace to show 1, then 2, then 3... points.
            plotlyPointsTraceIndex = traces.length;
            
            // Small z-offset to prevent z-fighting with surface
            const zOffset = 0.3;
            
                const traj = algorithmTrajectories[currentAlgorithm];
            if (traj) {
                traces.push({
                    type: 'scatter3d',
                    mode: 'markers',
                    x: [],
                    y: [],
                    z: [],
                    marker: {
                        size: 6,
                        color: [],
                        symbol: 'circle',
                        line: { color: 'white', width: 1 }
                    },
                    name: `${currentAlgorithm}`,
                    hovertemplate: '<b>Iteration %{text}</b><br>θ<sub>D</sub>: %{x:.4f}<br>θ<sub>M</sub>: %{y:.4f}<br>DPR: %{z:.4f}<extra></extra>',
                    text: [],
                    showlegend: false
                });
                
                // 4. Trajectory Line Segments (One trace per segment)
                // We create them all now but hidden.
                plotlyLineTraceStartIndex = traces.length;
                
                for (let i = 0; i < traj.p_d.length - 1; i++) {
                    // Source color determines line color (like 2D chart)
                    // Point i is source. i=0 (Blue), i=1 (Orange), i=2 (Blue)...
                    // Even indices = Blue, Odd indices = Orange
                    const lineColor = (i % 2 === 0) ? '#8DA0CB' : '#E5C494';
                    const label = (i % 2 === 0) ? 'Training step' : 'Deployment (distribution shift)';
                    
                    traces.push({
                        type: 'scatter3d',
                        mode: 'lines',
                        x: [traj.p_d[i], traj.p_d[i+1]],
                        y: [traj.p_m[i], traj.p_m[i+1]],
                        z: [traj.losses[i] + zOffset, traj.losses[i+1] + zOffset],
                        line: { color: lineColor, width: 5 },
                        hovertemplate: `<b>${label}</b><extra></extra>`,
                        showlegend: false,
                        visible: false // Start hidden
                    });
                }
            }
            
            const layout = {
                scene: {
                    xaxis: { title: 'θ<sub>D</sub>', titlefont: { size: 12 } },
                    yaxis: { title: 'θ<sub>M</sub>', titlefont: { size: 12 } },
                    zaxis: { title: 'DPR(θ<sub>D</sub>,θ<sub>M</sub>)', titlefont: { size: 12 } },
                    camera: {
                        eye: { x: -1.75, y: 1.65, z: 1.5 },
                        up: { x: 0, y: 0, z: 1 },
                        center: { x: 0, y: 0, z: 0 }
                    }
                },
                showlegend: false,
                margin: { l: 0, r: 0, b: 0, t: 0 },
                autosize: true
            };
            
            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false,
                modeBarButtonsToRemove: ['toImage']
            };
            
            Plotly.newPlot('plot', traces, layout, config);
        }
        
        // Update 3D plot based on exact step (Line then Point logic)
        function updatePlot(step) {
            if (currentAlgorithm === 'none' || !algorithmTrajectories[currentAlgorithm]) return;
            const traj = algorithmTrajectories[currentAlgorithm];
            
            // Logic:
            // Step 1: Point 0
            // Step 2: Point 0 + Line(0->1)
            // Step 3: Point 0, Point 1 + Line(0->1)
            // Step 4: Point 0, Point 1 + Line(0->1), Line(1->2)
            // ...
            
            // Calculate number of points to show
            // Odd steps add a point (1->1, 3->2, 5->3...)
            // Even steps keep same points (2->1, 4->2...)
            // Formula: ceil(step / 2)
            const numPoints = Math.ceil(step / 2);
            
            // Update Points Trace
            const p_d = traj.p_d.slice(0, numPoints);
            const p_m = traj.p_m.slice(0, numPoints);
            const losses = traj.losses.slice(0, numPoints).map(z => z + 0.3); // Add zOffset here too
            const iterations = traj.iterations.slice(0, numPoints);
            
            // Colors for points: P0=Blue, P1=Orange, P2=Blue...
            const pointColors = iterations.map((_, i) => 
                (i % 2 === 0) ? '#7BA3D1' : '#D4A574'
            );
            
            Plotly.restyle('plot', {
                x: [p_d],
                y: [p_m],
                z: [losses],
                text: [iterations],
                'marker.color': [pointColors]
            }, [plotlyPointsTraceIndex]);
            
            // Calculate number of lines to show
            // Step 1: 0 lines
            // Step 2: 1 line
            // Step 3: 1 line
            // Step 4: 2 lines
            // Formula: floor(step / 2)
            const numLines = Math.floor(step / 2);
            
            // Toggle visibility of line traces
            // We have trace indices from plotlyLineTraceStartIndex upwards
            const totalLines = traj.p_d.length - 1;
            const updates = {};
            const traceIndices = [];
            
            for (let i = 0; i < totalLines; i++) {
                traceIndices.push(plotlyLineTraceStartIndex + i);
                updates[i] = (i < numLines); // true if should be visible
            }
            
            // Batch update visibility
            // Construct array of visibility values matching traceIndices
            const visibilityArray = traceIndices.map(idx => {
                const lineIndex = idx - plotlyLineTraceStartIndex;
                return lineIndex < numLines;
            });
            
            Plotly.restyle('plot', { visible: visibilityArray }, traceIndices);
        }
        
        // Create the 2D risk chart (right side) - with progressive reveal
        async function createRiskChart() {
            const container = document.getElementById('risk-chart');
            if (!container) return;

            // Load risk iterations data
            const cacheBuster = new Date().getTime();
            try {
                const response = await fetch(`./json/risk_iterations.json?v=${cacheBuster}`);
                const data = await response.json();
                riskChartData = data.points;
            } catch (error) {
                console.error('Error loading risk iterations:', error);
                return;
            }

            // Update total steps based on actual data
            totalSteps = riskChartData.length + (riskChartData.length - 1); // points + lines

            // Set up dimensions
            const containerHeight = 380;
            const margin = { top: 20, right: 30, bottom: 45, left: 50 };
            const width = 450 - margin.left - margin.right;
            const height = containerHeight - margin.top - margin.bottom;

            // Create SVG
            const svg = d3.select('#risk-chart')
                .append('svg')
                .attr('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
                .attr('width', '100%')
                .style('max-width', '450px')
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Set up scales
            const values = riskChartData.map(p => p.value);
            const minVal = d3.min(values);
            const maxVal = d3.max(values);
            const padding = Math.max((maxVal - minVal) * 0.1, 1);

            const xScale = d3.scaleLinear()
                .domain([0, 6])
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain([minVal - padding, maxVal + padding])
                .range([height, 0]);
            
            riskChartScales = { xScale, yScale };

            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale).ticks(7))
                .style('font-size', '12px');

            svg.append('g')
                .call(d3.axisLeft(yScale).ticks(7))
                .style('font-size', '12px');

            // Add axis labels
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height + 38)
                .style('text-anchor', 'middle')
                .style('font-size', '13px')
                .text('Iteration');

            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -38)
                .style('text-anchor', 'middle')
                .style('font-size', '13px')
                .text('Risk');

            // Create lines (initially hidden)
            for (let i = 0; i < riskChartData.length - 1; i++) {
                const currentPoint = riskChartData[i];
                const nextPoint = riskChartData[i + 1];
                const lineColor = currentPoint.color === 'blue' ? '#8DA0CB' : '#E5C494';

                const line = svg.append('line')
                    .attr('x1', xScale(currentPoint.iteration))
                    .attr('y1', yScale(currentPoint.value))
                    .attr('x2', xScale(nextPoint.iteration))
                    .attr('y2', yScale(nextPoint.value))
                    .attr('stroke', lineColor)
                    .attr('stroke-width', 2)
                    .attr('opacity', 0);
                
                riskChartLines.push(line);
            }

            // Create points (initially hidden)
            riskChartData.forEach(point => {
                const circle = svg.append('circle')
                    .attr('cx', xScale(point.iteration))
                    .attr('cy', yScale(point.value))
                    .attr('r', 5)
                    .attr('fill', point.color === 'blue' ? '#8DA0CB' : '#E5C494')
                    .attr('opacity', 0);
                
                riskChartPoints.push(circle);
            });

            // Define arrowhead markers
            const defs = svg.append('defs');
            ['blue', 'orange', 'black'].forEach(color => {
                const fillColor = color === 'blue' ? '#8DA0CB' : color === 'orange' ? '#E5C494' : 'black';
                defs.append('marker')
                    .attr('id', `arrowhead-static-${color}`)
                    .attr('viewBox', '0 0 10 10')
                    .attr('refX', 8)
                    .attr('refY', 5)
                    .attr('markerWidth', 6)
                    .attr('markerHeight', 6)
                    .attr('orient', 'auto')
                    .append('path')
                    .attr('d', 'M 0 0 L 10 5 L 0 10 z')
                    .attr('fill', fillColor);
            });
        }
        
        // Update 2D risk chart based on elements to show
        function updateRiskChart(elementsToShow) {
            let elementCount = 0;
            
            for (let i = 0; i < riskChartPoints.length; i++) {
                // Show point
                if (elementCount < elementsToShow) {
                    riskChartPoints[i].attr('opacity', 1);
                    elementCount++;
                } else {
                    riskChartPoints[i].attr('opacity', 0);
                }
                
                // Show line after point (if there's a line for this point)
                if (i < riskChartLines.length) {
                    if (elementCount < elementsToShow) {
                        riskChartLines[i].attr('opacity', 1);
                        elementCount++;
                    } else {
                        riskChartLines[i].attr('opacity', 0);
                    }
                }
            }
        }
        
        // Master update function - synchronizes both visualizations
        function updateVisualization(step, clickedBtn = null) {
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            
            // Show loading on clicked button and disable both
            if (clickedBtn) {
                clickedBtn.classList.add('loading');
                prevBtn.disabled = true;
                nextBtn.disabled = true;
            }
            
            currentStep = Math.max(1, Math.min(totalSteps, step));
            
            // Use requestAnimationFrame to let the spinner render first
            requestAnimationFrame(() => {
                // Small timeout to ensure spinner is painted
                setTimeout(() => {
                    // Update 2D chart
                    updateRiskChart(currentStep);
                    
                    // Update 3D plot
                    updatePlot(currentStep);
                    
                    // Update UI
                    document.getElementById('step-current').textContent = currentStep;
                    
                    // Remove loading and update button states
                    if (clickedBtn) {
                        clickedBtn.classList.remove('loading');
                    }
                    prevBtn.disabled = currentStep === 1;
                    nextBtn.disabled = currentStep === totalSteps;
                }, 10);
            });
        }
        
        // Initialize
        async function init() {
            await loadLandscape();
            await loadTrajectory('PerfGDReparam', 'RGD_1d_0.25lr_10.json', 6); // Limit to 6 iterations (13 points) to match 2D data
            
            document.getElementById('loading').style.display = 'none';
            document.querySelector('.controls').style.display = 'block';
            
            createPlot();
            await createRiskChart();
            
            // Set up button handlers
            const nextBtn = document.getElementById('next-btn');
            const prevBtn = document.getElementById('prev-btn');
            nextBtn.onclick = () => updateVisualization(currentStep + 1, nextBtn);
            prevBtn.onclick = () => updateVisualization(currentStep - 1, prevBtn);
            
            // Initialize with first step
            updateVisualization(1);
            
            window.addEventListener('resize', () => {
                Plotly.Plots.resize('plot');
            });
        }
        
        init();
    </script>
</body>
</html>
